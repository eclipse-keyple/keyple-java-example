///////////////////////////////////////////////////////////////////////////////
//  GRADLE CONFIGURATION
///////////////////////////////////////////////////////////////////////////////

import java.time.OffsetDateTime
import java.time.format.DateTimeFormatter

plugins {
  java
  `maven-publish`
  signing
  id("com.diffplug.spotless") version "7.0.4"
}

///////////////////////////////////////////////////////////////////////////////
//  APP CONFIGURATION
///////////////////////////////////////////////////////////////////////////////

dependencies {
  // Begin Keyple configuration (generated by
  // 'https://keyple.org/components/overview/configuration-wizard/')
  implementation("org.eclipse.keypop:keypop-reader-java-api:2.0.1")
  implementation("org.eclipse.keypop:keypop-calypso-card-java-api:2.1.2")
  implementation("org.eclipse.keypop:keypop-calypso-crypto-legacysam-java-api:0.7.0")
  implementation("org.eclipse.keyple:keyple-common-java-api:2.0.2")
  implementation("org.eclipse.keyple:keyple-util-java-lib:2.4.0")
  implementation("org.eclipse.keyple:keyple-service-java-lib:3.3.5")
  implementation("org.eclipse.keyple:keyple-service-resource-java-lib:3.1.0")
  implementation("org.eclipse.keyple:keyple-card-calypso-java-lib:3.1.8")
  implementation("org.eclipse.keyple:keyple-card-calypso-crypto-legacysam-java-lib:0.9.0")
  implementation("org.eclipse.keyple:keyple-card-calypso-crypto-pki-java-lib:0.2.2")
  implementation("org.eclipse.keyple:keyple-plugin-pcsc-java-lib:2.5.2")
  implementation("org.eclipse.keyple:keyple-plugin-stub-java-lib:2.2.1")
  // End Keyple configuration
  implementation("org.slf4j:slf4j-simple:1.7.32")
  implementation("com.google.code.gson:gson:2.10.1")
}

val buildTimeAndDate = OffsetDateTime.now()
val buildDate = DateTimeFormatter.ISO_LOCAL_DATE.format(buildTimeAndDate)
val buildTime = DateTimeFormatter.ofPattern("HH:mm:ss.SSSZ").format(buildTimeAndDate)

tasks {
  register("fatJarTN313", Jar::class.java) {
    archiveClassifier.set("TN313-fat")
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    manifest {
      attributes(
          "Main-Class" to
              "org.eclipse.keyple.card.calypso.example.UseCase10_SessionTrace_TN313.Main_SessionTrace_TN313_Pcsc",
          "Created-By" to
              "${System.getProperty("java.version")} (${System.getProperty("java.vendor")} ${
                    System.getProperty(
                        "java.vm.version"
                    )
                })",
          "Build-Date" to buildDate,
          "Build-Time" to buildTime,
          "Specification-Title" to project.name,
          "Implementation-Version" to project.version,
          "Bundle-Name" to project.name,
          "Bundle-Description" to project.description)
    }
    from(
        configurations.runtimeClasspath
            .get()
            .onEach { println("add from dependencies: ${it.name}") }
            .map { if (it.isDirectory) it else zipTree(it) })
    val sourcesMain = sourceSets.main.get()
    sourcesMain.allSource.forEach { println("add from sources: ${it.name}") }
    from(sourcesMain.output)
  }
  register("fatJarPerfEmbeddedValidation", Jar::class.java) {
    archiveClassifier.set("PerfEmbeddedValidation-fat")
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    manifest {
      attributes(
          "Main-Class" to
              "org.eclipse.keyple.card.calypso.example.UseCase12_PerformanceMeasurement_EmbeddedValidation.Main_PerformanceMeasurement_EmbeddedValidation_Pcsc",
          "Created-By" to
              "${System.getProperty("java.version")} (${System.getProperty("java.vendor")} ${
                    System.getProperty(
                        "java.vm.version"
                    )
                })",
          "Build-Date" to buildDate,
          "Build-Time" to buildTime,
          "Specification-Title" to project.name,
          "Implementation-Version" to project.version,
          "Bundle-Name" to project.name,
          "Bundle-Description" to project.description)
    }
    from(
        configurations.runtimeClasspath
            .get()
            .onEach { println("add from dependencies: ${it.name}") }
            .map { if (it.isDirectory) it else zipTree(it) })
    val sourcesMain = sourceSets.main.get()
    sourcesMain.allSource.forEach { println("add from sources: ${it.name}") }
    from(sourcesMain.output)
  }
  register("fatJarPerfDistributedReloading", Jar::class.java) {
    archiveClassifier.set("PerfDistributedReloading-fat")
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    manifest {
      attributes(
          "Main-Class" to
              "org.eclipse.keyple.card.calypso.example.UseCase13_PerformanceMeasurement_DistributedReloading.Main_PerformanceMeasurement_DistributedReloading_Pcsc",
          "Created-By" to
              "${System.getProperty("java.version")} (${System.getProperty("java.vendor")} ${
                    System.getProperty(
                        "java.vm.version"
                    )
                })",
          "Build-Date" to buildDate,
          "Build-Time" to buildTime,
          "Specification-Title" to project.name,
          "Implementation-Version" to project.version,
          "Bundle-Name" to project.name,
          "Bundle-Description" to project.description)
    }
    from(
        configurations.runtimeClasspath
            .get()
            .onEach { println("add from dependencies: ${it.name}") }
            .map { if (it.isDirectory) it else zipTree(it) })
    val sourcesMain = sourceSets.main.get()
    sourcesMain.allSource.forEach { println("add from sources: ${it.name}") }
    from(sourcesMain.output)
  }
}

///////////////////////////////////////////////////////////////////////////////
//  STANDARD CONFIGURATION FOR JAVA PROJECTS
///////////////////////////////////////////////////////////////////////////////

if (project.hasProperty("releaseTag")) {
  project.version = project.property("releaseTag") as String
  println("Release mode: version set to ${project.version}")
} else {
  println("Development mode: version is ${project.version}")
}

val javaSourceLevel: String by project
val javaTargetLevel: String by project

java {
  sourceCompatibility = JavaVersion.toVersion(javaSourceLevel)
  targetCompatibility = JavaVersion.toVersion(javaTargetLevel)
  println("Compiling Java $sourceCompatibility to Java $targetCompatibility.")
  withJavadocJar()
  withSourcesJar()
}

fun copyLicenseFiles() {
  val metaInfDir = File(layout.buildDirectory.get().asFile, "resources/main/META-INF")
  val licenseFile = File(project.rootDir, "LICENSE")
  val noticeFile = File(project.rootDir, "NOTICE.md")
  metaInfDir.mkdirs()
  licenseFile.copyTo(File(metaInfDir, "LICENSE"), overwrite = true)
  noticeFile.copyTo(File(metaInfDir, "NOTICE.md"), overwrite = true)
}

tasks {
  spotless {
    java {
      target("src/**/*.java")
      licenseHeaderFile("${project.rootDir}/LICENSE_HEADER")
      importOrder("java", "javax", "org", "com", "")
      removeUnusedImports()
      googleJavaFormat()
    }
    kotlinGradle {
      target("**/*.kts")
      ktfmt()
    }
  }
  test {
    useJUnitPlatform()
    testLogging { events("passed", "skipped", "failed") }
  }
  javadoc {
    dependsOn(processResources)
    val javadocLogo = project.findProperty("javadoc.logo") as String
    val javadocCopyright = project.findProperty("javadoc.copyright") as String
    val titleProperty = project.findProperty("title") as String
    (options as StandardJavadocDocletOptions).apply {
      overview = "src/main/javadoc/overview.html"
      windowTitle = "$titleProperty - ${project.version}"
      header(
          "<div style=\"margin-top: 7px\">$javadocLogo $titleProperty - ${project.version}</div>")
      docTitle("$titleProperty - ${project.version}")
      use(true)
      bottom(javadocCopyright)
      encoding = "UTF-8"
      charSet = "UTF-8"
      if (JavaVersion.current().isJava11Compatible) {
        addBooleanOption("html5", true)
        addStringOption("Xdoclint:none", "-quiet")
      }
    }
    doFirst { println("Generating Javadoc for ${project.name} version ${project.version}") }
  }
  jar {
    dependsOn(processResources)
    doFirst { copyLicenseFiles() }
    manifest {
      attributes(
          mapOf(
              "Implementation-Title" to (project.findProperty("title") as String),
              "Implementation-Version" to project.version,
              "Implementation-Vendor" to (project.findProperty("organization.name") as String),
              "Implementation-URL" to (project.findProperty("project.url") as String),
              "Specification-Title" to (project.findProperty("title") as String),
              "Specification-Version" to project.version,
              "Specification-Vendor" to (project.findProperty("organization.name") as String),
              "Created-By" to
                  "${System.getProperty("java.version")} (${System.getProperty("java.vendor")})",
              "Build-Jdk" to System.getProperty("java.version")))
    }
  }
  named<Jar>("sourcesJar") {
    doFirst { copyLicenseFiles() }
    manifest {
      attributes(
          mapOf(
              "Implementation-Title" to "${project.findProperty("title") as String} Sources",
              "Implementation-Version" to project.version))
    }
  }
  named<Jar>("javadocJar") {
    dependsOn(javadoc)
    doFirst { copyLicenseFiles() }
    manifest {
      attributes(
          mapOf(
              "Implementation-Title" to "${project.findProperty("title") as String} Documentation",
              "Implementation-Version" to project.version))
    }
  }
}

publishing {
  publications {
    create<MavenPublication>("mavenJava") {
      from(components["java"])
      pom {
        name.set(project.findProperty("title") as String)
        description.set(project.findProperty("description") as String)
        url.set(project.findProperty("project.url") as String)
        licenses {
          license {
            name.set(project.findProperty("license.name") as String)
            url.set(project.findProperty("license.url") as String)
            distribution.set(project.findProperty("license.distribution") as String)
          }
        }
        developers {
          developer {
            name.set(project.findProperty("developer.name") as String)
            email.set(project.findProperty("developer.email") as String)
          }
        }
        organization {
          name.set(project.findProperty("organization.name") as String)
          url.set(project.findProperty("organization.url") as String)
        }
        scm {
          connection.set(project.findProperty("scm.connection") as String)
          developerConnection.set(project.findProperty("scm.developerConnection") as String)
          url.set(project.findProperty("scm.url") as String)
        }
        ciManagement {
          system.set(project.findProperty("ci.system") as String)
          url.set(project.findProperty("ci.url") as String)
        }
        properties.set(
            mapOf(
                "project.build.sourceEncoding" to "UTF-8",
                "maven.compiler.source" to javaSourceLevel,
                "maven.compiler.target" to javaTargetLevel))
      }
    }
  }
  repositories {
    maven {
      if (project.hasProperty("sonatypeURL")) {
        url = uri(project.property("sonatypeURL") as String)
        credentials {
          username = project.property("sonatypeUsername") as String
          password = project.property("sonatypePassword") as String
        }
      }
    }
  }
}

signing {
  if (project.hasProperty("releaseTag")) {
    useGpgCmd()
    sign(publishing.publications["mavenJava"])
  }
}
